* ##### 数据结构

  * ###### [数组/链表](https://www.cnblogs.com/xiaoyouPrince/p/8043798.html)

    数组和链表都可作为线性表，数组优于读取，链表优于插入  
    数组要求连续空间，链表要多存储后继节点的引用

  * ###### 队列/栈

    都是操作受限的线性表  
    队列先进先出，栈先进后出

  * ###### 字符串

    * ###### [匹配](https://blog.csdn.net/u011467044/article/details/55008649)
  * ###### [二叉树](http://www.cnblogs.com/polly333/p/4740355.html)

    * ###### 遍历/查找

      先/中/后序遍历，递归容易实现  
      层序遍历，辅助栈实现

    * ###### 变种

      * ###### 平衡二叉树（AVL）
      * ###### 红黑树

        红黑树是一种具有红色和黑色链接的平衡查找树，同时满足：

        * 红色节点向左倾斜
        * 一个节点不可能有两个红色链接
        * 整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。

      * ###### B-树
      * ###### B+树
  * ###### 树/图

    * ###### 遍历/查找
* ##### [查找](https://www.cnblogs.com/yw09041432/p/5908444.html)

  * ###### 二分查找

    * 说明：元素必须是有序的，如果是无序的则要先进行排序操作。

    * 基本思想**：**也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。

    * 复杂度分析：最坏情况下，关键词比较次数为log2\(n+1\)，且期望时间复杂度为O\(log2n\)；
  * ###### 分块查找
* ##### 排序
* ##### 算法思想

  * ###### 递归和循环
  * ###### 回溯
  * ###### 贪婪算法
  * ###### 动态规划
  * ###### 位运算
* ##### 代码质量

  全面考虑所有可能的输出

  * ###### 规范性
  * ###### 完整性

    * ###### [功能测试，边界测试，负面测试](#)

      基本功能，边界条件，错误处理
  * ###### 鲁棒性

    * ###### 防御性编程，处理无效的输入

* ##### 思路

  * ###### 画图，举例，分解
* ##### 效率

  * ###### 时间
  * ###### 空间
* ##### 源代码

  * ###### 官方[C/C++](https://github.com/zhedahht/CodingInterviewChinese2)
  * ###### [Java](https://github.com/dmqm/CodingInterviews)



