* ##### 数据结构

  * ###### [数组/链表](https://www.cnblogs.com/xiaoyouPrince/p/8043798.html)

    数组和链表都可作为线性表，数组优于读取，链表优于插入  
    数组要求连续空间，链表要多存储后继节点的引用

  * ###### 队列/栈

    都是操作受限的线性表  
    队列先进先出，栈先进后出

  * ###### 字符串

    * ###### [匹配](https://blog.csdn.net/u011467044/article/details/55008649)
  * ###### [二叉树](http://www.cnblogs.com/polly333/p/4740355.html)

    * ###### 遍历/查找

      先/中/后序遍历，递归容易实现  
      层序遍历，辅助栈实现

    * ###### 变种（查找优化）

      * ###### 二叉搜索树
      * ###### 平衡二叉树（AVL）
      * ###### 红黑树

        红黑树是一种具有红色和黑色链接的平衡查找树，同时满足：

        * 红色节点向左倾斜
        * 一个节点不可能有两个红色链接
        * 整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。

      * ###### [B树](https://www.cnblogs.com/George1994/p/7008732.html)

        * ###### B树

          每个结点至多拥有m棵子树；  
          根结点至少拥有两颗子树（存在子树的情况下）；  
          除了根结点以外，其余每个分支结点至少拥有 m/2 棵子树；  
          所有的叶结点都在同一层上；  
          有 k 棵子树的分支结点则存在 k-1 个关键码，关键码按照递增次序进行排列；  
          关键字数量需要满足ceil\(m/2\)-1 &lt;= n &lt;= m-1；

        * ###### B+树（经常作为索引）

          根结点只有一个，分支数量范围为\[2，m\]；  
          分支结点，每个结点包含分支数范围为\[ceil\(m/2\), m\]；  
          分支结点的关键字数量等于其子分支的数量减一，关键字的数量范围为\[ceil\(m/2\)-1, m-1\]，关键字顺序递增；  
          所有叶子结点都在同一层；
  * ###### 树/图

    * ###### 遍历/查找

      * ###### 广度优先BFS
      * ###### 深度优先DFS
    * ###### 最小生成树

      * ###### Prim 普里姆算法

        该算法采用贪心思想，在图中任意选择一结点构建一颗生成树然后从所有与该生成树相邻的结点中取出最近的结点和边加入到生成树中．直到所有的结点都加入到该生成树中．  
        时间复杂度ElogV

      * ###### 克鲁斯卡尔

        克鲁斯卡尔算法每次从剩余的边中选择一个最小的边，如果当前边和已选取的边构成回路，则放弃该并选择下一个 最小边。如果不构成回路则将该边以及连接的两个结点加入的生成树中．直到完成整棵生成树的构建  
        时间复杂度ElogE
    * ###### 最短路径

      * ###### 迪杰斯特拉　Dijkstra

        Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T  
        初始时，原点 s 的路径权重被赋为 0 （dis\[s\] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis\[m\]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。  
        然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点，然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。  
        然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。  
        时间复杂度ElogV

      * ###### 弗洛伊德　Floyed

        是采用动态规划的思想计算任意两个结点之间的最短路径.  
        初始化距离矩阵，对于所有两点之间的距离是边的 权，如果两点之间没有边相连，则权为无穷大。  
        对于每一对顶点 u 和 v，看看其他结点中否存在一个顶点 w 使 得从 u 到 w 再到 v 比已知的路径更短。如果是更新它。

        时间复杂度O\(V^3\)
* ##### [查找](https://www.cnblogs.com/yw09041432/p/5908444.html)

  * ###### 二分查找

    * 说明：元素必须是有序的，如果是无序的则要先进行排序操作。

    * 基本思想**：**也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。

    * 复杂度分析：最坏情况下，关键词比较次数为log2\(n+1\)，且期望时间复杂度为O\(log2n\)；
  * ###### 分块查找

    分块查找又称索引顺序查找，它是顺序查找的一种改进方法。

    * 算法思想：将n个数据元素"按块有序"划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须"按块有序"；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……

  * ###### 哈希查找

    哈希表是根据设定的哈希函数H\(key\)和处理冲突方法将一组关键字映射到一个有限的地址区间上，并将关键字对应的值存储在该地址空间，可以通过关键字快速获取对应的值，这种表称为哈希表或散列，所得存储位置称为哈希地址或散列地址

    * ###### 哈希函数

      直接寻址法，数字分析法，平方取中法，折叠法，除留余数法

    * ###### 冲突解决

      开放定址法，拉链法
* ##### [排序](https://www.cnblogs.com/onepixel/articles/7674659.html)

  * ###### 冒泡排序
  * ###### 选择排序
  * ###### 插入排序
  * ###### 希尔排序
  * ###### 归并排序
  * ###### 快速排序
  * ###### 堆排序
  * ###### 计数排序

  * ###### 堆排序
* ##### 算法思想

  * ###### 递归和循环
  * ###### 回溯
  * ###### 贪婪算法
  * ###### 动态规划
  * ###### 位运算
* ##### 代码质量

  全面考虑所有可能的输出

  * ###### 规范性
  * ###### 完整性

    * ###### [功能测试，边界测试，负面测试](#)

      基本功能，边界条件，错误处理
  * ###### 鲁棒性

    * ###### 防御性编程，处理无效的输入

* ##### 思路

  * ###### 画图，举例，分解
* ##### 效率

  * ###### 时间
  * ###### 空间
* ##### 源代码

  * ###### 官方[C/C++](https://github.com/zhedahht/CodingInterviewChinese2)
  * ###### [Java](https://github.com/dmqm/CodingInterviews)



