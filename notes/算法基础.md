* ##### 数据结构

  * ###### [数组/链表](https://www.cnblogs.com/xiaoyouPrince/p/8043798.html)

    数组和链表都可作为线性表，数组优于读取，链表优于插入  
    数组要求连续空间，链表要多存储后继节点的引用

  * ###### 队列/栈

    都是操作受限的线性表  
    队列先进先出，栈先进后出

  * ###### 字符串

    * ###### [匹配](https://blog.csdn.net/u011467044/article/details/55008649)
  * ###### [二叉树](http://www.cnblogs.com/polly333/p/4740355.html)

    * ###### 遍历/查找

      先/中/后序遍历，递归容易实现  
      层序遍历，辅助栈实现

    * ###### 变种（查找优化）

      * ###### 二叉搜索树
      * ###### 平衡二叉树（AVL）
      * ###### 红黑树

        红黑树是一种具有红色和黑色链接的平衡查找树，同时满足：

        * 红色节点向左倾斜
        * 一个节点不可能有两个红色链接
        * 整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。

      * ###### [B树](https://www.cnblogs.com/George1994/p/7008732.html)

        * ###### B树

          每个结点至多拥有m棵子树；  
          根结点至少拥有两颗子树（存在子树的情况下）；  
          除了根结点以外，其余每个分支结点至少拥有 m/2 棵子树；  
          所有的叶结点都在同一层上；  
          有 k 棵子树的分支结点则存在 k-1 个关键码，关键码按照递增次序进行排列；  
          关键字数量需要满足\[ceil\(m/2\)-1 &lt;= n &lt;= m-1\]；

        * ###### B+树（经常作为索引）

          根结点只有一个，分支数量范围为\[2，m\]；  
          分支结点，每个结点包含分支数范围为\[ceil\(m/2\), m\]；  
          分支结点的关键字数量等于其子分支的数量减一，关键字的数量范围为\[ceil\(m/2\)-1, m-1\]，关键字顺序递增；  
          所有叶子结点都在同一层；
  * ###### 树/图

    * ###### 遍历/查找

      * ###### 广度优先BFS
      * ###### 深度优先DFS
    * ###### 最小生成树

      * ###### Prim 普里姆算法

        该算法采用贪心思想，在图中任意选择一结点构建一颗生成树然后从所有与该生成树相邻的结点中取出最近的结点和边加入到生成树中．直到所有的结点都加入到该生成树中．  
        时间复杂度ElogV

      * ###### 克鲁斯卡尔

        克鲁斯卡尔算法每次从剩余的边中选择一个最小的边，如果当前边和已选取的边构成回路，则放弃该并选择下一个 最小边。如果不构成回路则将该边以及连接的两个结点加入的生成树中．直到完成整棵生成树的构建  
        时间复杂度ElogE
    * ###### 最短路径

      * ###### 迪杰斯特拉　Dijkstra

        Dijkstra算法采用的是一种贪心的策略  
        声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T  
        初始时，原点 s 的路径权重被赋为 0 （dis\[s\] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis\[m\]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。  
        然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点，然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。  
        然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。  
        时间复杂度ElogV

      * ###### 弗洛伊德　Floyed

        是采用动态规划的思想计算任意两个结点之间的最短路径.  
        初始化距离矩阵，对于所有两点之间的距离是边的 权，如果两点之间没有边相连，则权为无穷大。  
        对于每一对顶点 u 和 v，看看其他结点中否存在一个顶点 w 使 得从 u 到 w 再到 v 比已知的路径更短。如果是更新它。

        时间复杂度O\(V^3\)
* ##### [查找](https://www.cnblogs.com/yw09041432/p/5908444.html)

  * ###### 二分查找

    * 说明：元素必须是有序的，如果是无序的则要先进行排序操作。

    * 基本思想**：**也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。

    * 复杂度分析：最坏情况下，关键词比较次数为log2\(n+1\)，且期望时间复杂度为O\(log2n\)；
  * ###### 分块查找

    分块查找又称索引顺序查找，它是顺序查找的一种改进方法。

    * 算法思想：将n个数据元素"按块有序"划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须"按块有序"；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……

  * ###### 哈希查找

    哈希表是根据设定的哈希函数H\(key\)和处理冲突方法将一组关键字映射到一个有限的地址区间上，并将关键字对应的值存储在该地址空间，可以通过关键字快速获取对应的值，这种表称为哈希表或散列，所得存储位置称为哈希地址或散列地址

    * ###### 哈希函数

      直接寻址法，数字分析法，平方取中法，折叠法，除留余数法

    * ###### 冲突解决

      开放定址法，拉链法
* ##### [排序](https://www.cnblogs.com/onepixel/articles/7674659.html)

  * ###### 冒泡排序

    1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
    2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
    3. 针对所有的元素重复以上的步骤，除了最后一个；
    4. 重复步骤1~3，直到排序完成。
  * ###### 选择排序

    1. 初始状态：无序区为R\[1..n\]，有序区为空；
    2. 第i趟排序\(i=1,2,3…n-1\)开始时，当前有序区和无序区分别为R\[1..i-1\]和R\(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R\[k\]，将它与无序区的第1个记录R交换，使R\[1..i\]和R\[i+1..n\)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；
    3. n-1趟结束，数组有序化了。
  * ###### 插入排序

    插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

  * ###### 希尔排序

    先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：

    1. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；
    2. 按增量序列个数k，对序列进行k 趟排序；
    3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

  * ###### 归并排序

    归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。

    1. 把长度为n的输入序列分成两个长度为n/2的子序列；
    2. 对这两个子序列分别采用归并排序；
    3. 将两个排序好的子序列合并成一个最终的排序序列。

  * ###### 快速排序

    快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

    1. 从数列中挑出一个元素，称为 “基准”（pivot）；
    2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
    3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

  * ###### 堆排序

    堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

    1. 将初始待排序关键字序列\(R1,R2….Rn\)构建成大顶堆，此堆为初始的无序区；
    2. 将堆顶元素R\[1\]与最后一个元素R\[n\]交换，此时得到新的无序区\(R1,R2,……Rn-1\)和新的有序区\(Rn\),且满足R\[1,2…n-1\]&lt;=R\[n\]；
    3. 由于交换后新的堆顶R\[1\]可能违反堆的性质，因此需要对当前无序区\(R1,R2,……Rn-1\)调整为新堆，然后再次将R\[1\]与无序区最后一个元素交换，得到新的无序区\(R1,R2….Rn-2\)和新的有序区\(Rn-1,Rn\)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。

  * ###### 计数排序

    计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

    1. 找出待排序的数组中最大和最小的元素；
    2. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；
    3. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；
    4. 反向填充目标数组：将每个元素i放在新数组的第C\(i\)项，每放一个元素就将C\(i\)减去1。

  * ###### 桶排序

    桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 \(Bucket sort\)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。

    1. 设置一个定量的数组当作空桶；
    2. 遍历输入数据，并且把数据一个一个放到对应的桶里去；
    3. 对每个不是空的桶进行排序；
    4. 从不是空的桶里把排好序的数据拼接起来。 

  * ###### 基数排序

    基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。

    1. 取得数组中的最大数，并取得位数；
    2. arr为原始数组，从最低位开始取每个位组成radix数组；
    3. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；
* ##### 算法思想

  * ###### 递归和循环
  * ###### 回溯
  * ###### 贪婪算法
  * ###### 动态规划
* ##### 代码质量

  全面考虑所有可能的输出

  * ###### 规范性
  * ###### 完整性

    * ###### [功能测试，边界测试，负面测试](#)

      基本功能，边界条件，错误处理
  * ###### 鲁棒性

    * ###### 防御性编程，处理无效的输入

* ##### 思路

  * ###### 画图，举例，分解
* ##### 效率

  * ###### 时间
  * ###### 空间
* ##### 源代码

  * ###### 官方[C/C++](https://github.com/zhedahht/CodingInterviewChinese2)
  * ###### [Java](https://github.com/dmqm/CodingInterviews)



