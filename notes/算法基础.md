* ##### 数据结构

  * ###### [数组/链表](https://www.cnblogs.com/xiaoyouPrince/p/8043798.html)

    数组和链表都可作为线性表，数组优于读取，链表优于插入  
    数组要求连续空间，链表要多存储后继节点的引用

  * ###### 队列/栈

    都是操作受限的线性表  
    队列先进先出，栈先进后出

  * ###### 字符串

    * ###### [匹配](https://blog.csdn.net/u011467044/article/details/55008649)
  * ###### [二叉树](http://www.cnblogs.com/polly333/p/4740355.html)

    * ###### 遍历/查找

      先/中/后序遍历，递归容易实现  
      层序遍历，辅助栈实现

    * ###### 变种（查找优化）

      * ###### 二叉搜索树
      * ###### 平衡二叉树（AVL）
      * ###### 红黑树

        红黑树是一种具有红色和黑色链接的平衡查找树，同时满足：

        * 红色节点向左倾斜
        * 一个节点不可能有两个红色链接
        * 整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。

      * ###### [B树](https://www.cnblogs.com/George1994/p/7008732.html)

        * ###### B树

          每个结点至多拥有m棵子树；  
          根结点至少拥有两颗子树（存在子树的情况下）；  
          除了根结点以外，其余每个分支结点至少拥有 m/2 棵子树；  
          所有的叶结点都在同一层上；  
          有 k 棵子树的分支结点则存在 k-1 个关键码，关键码按照递增次序进行排列；  
          关键字数量需要满足ceil\(m/2\)-1 &lt;= n &lt;= m-1；

        * ###### B+树（经常作为索引）

          根结点只有一个，分支数量范围为\[2，m\]；  
          分支结点，每个结点包含分支数范围为\[ceil\(m/2\), m\]；  
          分支结点的关键字数量等于其子分支的数量减一，关键字的数量范围为\[ceil\(m/2\)-1, m-1\]，关键字顺序递增；  
          所有叶子结点都在同一层；
  * ###### 树/图

    * ###### 遍历/查找

      * ###### 广度优先BFS
      * ###### 深度优先DFS
    * ###### 最小生成树

      * ###### Prim 普里姆算法

        该算法采用贪心思想，在图中任意选择一结点构建一颗生成树然后从所有与该生成树相邻的结点中取出最近的结点和边加入到生成树中．直到所有的结点都加入到该生成树中．  
        时间复杂度ElogV 

      * ###### 克鲁斯卡尔

        克鲁斯卡尔算法每次从剩余的边中选择一个最小的边，如果当前边和已选取的边构成回路，则放弃该并选择下一个 最小边。如果不构成回路则将该边以及连接的两个结点加入的生成树中．直到完成整棵生成树的构建  
        时间复杂度ElogE
    * ###### 最短距离

      * ###### 迪杰斯特拉　Dijkstra

        应用了贪心算法模式，算法解决的是有向图中单个源点到其他顶点的最短路径问题．引进两个集合S和T。 S的作用是记录已求出最短路径的顶点\(以及相应的最短路径长度\)，而T则是记录还未求出最短路径的顶点\(以及该 顶点到起点s的距离\)。 初始时，S中只有起点v0；T中是除v0之外的顶点，并且T中顶点的路径是"起点s到该顶点的 路径"。从T中选择一个到v0最短的顶点vi并加入到S中.如果T集合中的结点以vi作为中转站到达s的距离比原来的小 则更新对应的值.依次迭代，直到将T中的所有结点加入S中。  
        算法复杂度　ElogV

      * ###### 弗洛伊德　Floyed
* ##### [查找](https://www.cnblogs.com/yw09041432/p/5908444.html)

  * ###### 二分查找

    * 说明：元素必须是有序的，如果是无序的则要先进行排序操作。

    * 基本思想**：**也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。

    * 复杂度分析：最坏情况下，关键词比较次数为log2\(n+1\)，且期望时间复杂度为O\(log2n\)；
  * ###### 分块查找

    分块查找又称索引顺序查找，它是顺序查找的一种改进方法。

    * 算法思想：将n个数据元素"按块有序"划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须"按块有序"；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……

  * ###### 哈希查找

    哈希表是根据设定的哈希函数H\(key\)和处理冲突方法将一组关键字映射到一个有限的地址区间上，并将关键字对应的值存储在该地址空间，可以通过关键字快速获取对应的值，这种表称为哈希表或散列，所得存储位置称为哈希地址或散列地址

    * ######  哈希函数

      直接寻址法，数字分析法，平方取中法，折叠法，除留余数法

    * ###### 冲突解决

      开放定址法，拉链法
* ##### 排序
* ##### 算法思想

  * ###### 递归和循环
  * ###### 回溯
  * ###### 贪婪算法
  * ###### 动态规划
  * ###### 位运算
* ##### 代码质量

  全面考虑所有可能的输出

  * ###### 规范性
  * ###### 完整性

    * ###### [功能测试，边界测试，负面测试](#)

      基本功能，边界条件，错误处理
  * ###### 鲁棒性

    * ###### 防御性编程，处理无效的输入

* ##### 思路

  * ###### 画图，举例，分解
* ##### 效率

  * ###### 时间
  * ###### 空间
* ##### 源代码

  * ###### 官方[C/C++](https://github.com/zhedahht/CodingInterviewChinese2)
  * ###### [Java](https://github.com/dmqm/CodingInterviews)



